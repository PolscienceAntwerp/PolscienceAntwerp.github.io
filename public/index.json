
    
    
    
    
    
    [{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"","tags":null,"title":"Flempar","type":"authors"},{"authors":["Evelien Willems and Frederik Heylen"],"categories":null,"content":"Writing your data to a CSV file In many cases, it might be useful to write the resulting data frame (here named result, but can be any name of your choosing) to a CSV file. Here’s the code to do so, making use of the write.csv2() function. Note that we included a line on how to drop columns containing data in list format, a format a CSV file cannot handle. Careful inspection of your data and its formats is therefore always necessary!\nresult %\u0026gt;% select_if(Negate(is.list)) %\u0026gt;% write.csv2(\u0026#34;result.csv\u0026#34;, row.names=FALSE) The CSV file can now be found in your local folder.\nApplying regexp to detect patterns in text Given the large bulks of text that can be gathered through the get_work() function, it might come in handy to structure this text a bit and apply regexp to detect patterns in the text, for instance, split up some text in multiple columns.\nTo illustrate this, we first query for a set of written questions (via get_work(), specifying fact=\u0026#34;written_questions\u0026#34; and type=\u0026#34;document\u0026#34;). These questions have a distinct structure: they are composed of a ‘question’ by an MP and an ‘answer’ by a minister. So let’s ensure that ‘question’ and ‘answer’ are stored in separate columns instead of being one big bulk of text. To do so, we use mutate from dplyr to create the extra columns and we extract the strings via str_extract from stringr (more info here).\nNote that this procedure entirely relies on identifying the string or sequence of words that marks the distinctive parts of a text. In our case, we identify ‘ANTWOORD op vraag’ (or: ANSWER to question) as introducing the distinction between the ‘question’ and ‘answer’ parts of the written question.\nFinally, note that we use regexp. You can look up all possibilities here.\nwritten_questions \u0026lt;- get_work(date_range_from=\u0026#34;2022-02-15\u0026#34; , date_range_to=\u0026#34;2022-02-20\u0026#34; , fact=\u0026#34;written_questions\u0026#34; , type=\u0026#34;document\u0026#34;) written_questions %\u0026gt;% mutate(vraag= str_extract(text, \u0026#34;.*(?\u0026lt;=ANTWOORD op )\u0026#34;)) %\u0026gt;% mutate(antwoord= str_extract(text, \u0026#34;(?\u0026lt;=ANTWOORD op ).*\u0026#34;) ) %\u0026gt;% write.csv2(\u0026#34;written_questions.csv\u0026#34;,row.names = FALSE) ","date":1664150400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664150400,"objectID":"480cae24afcacac0388362d460a4d351","permalink":"/post/2022_09_28_post/","publishdate":"2022-09-26T00:00:00Z","relpermalink":"/post/2022_09_28_post/","section":"post","summary":"Some nice extra's to the Flempar package.","tags":null,"title":"Flempar the extra's","type":"post"},{"authors":["Evelien Willems and Frederik Heylen"],"categories":null,"content":"knitr::opts_chunk$set(echo = TRUE) In this post we delve into the get_work() function and the parameters you can specify to query for more specific information.\nExample 1 - Basic functionalities First, we will query for all debates on current affairs (one possible type of parliamentary work - and the default option) organized in January-August 2022. We use the get_work() function. Indeed, in contrast to the get_mp function, you always need to specify a date range using the following arguments:\ndate_range_from: the start date YYYY-MM-DD date_range_to: the end date YYYY-MM-DD work_b \u0026lt;- get_work(date_range_from=\u0026#34;2022-01-01\u0026#34; , date_range_to=\u0026#34;2022-08-31\u0026#34;) work_b %\u0026gt;% tibble() %\u0026gt;% head(10) %\u0026gt;% View As an enormous amount of data can be retrieved through the get_work() function, it is highly recommended to test your query on a limited date range before expanding the date range to comprise multiple months to years.\nNote also that we include a chunk of code that lets you inspect the first 10 observations in the data frame created. This allows you to get a feel of the data obtained before diving in deeper. This is how the resulting data frame looks like:\nInspecting this data frame, shows you what the default parameters deliver. Namely, the “details” about “debates” in current affairs in “plenary” sessions for the “dates” specified. Though, much more is possible!\nThe get_work() function has the following arguments:\ndate_range_from: the start date YYYY-MM-DD date_range_to: the end date YYYY-MM-DD fact: options include “written_questions”, “debates”, “oral_questions_and_interpellations”, “parliamentary_initiatives”, and “council_hearings” type: options include “details”, “speech” and “documents” plen_comm: choose between plenary “plen” and commission “comm” sessions use_parallel: Boolean of which the default value is set to TRUE, select FALSE in case you do not have multiple workers to speed up the calls made raw: Boolean of which the default value is set to FALSE, select TRUE in case you wish to retrieve the unprocessed data extra_via_fact: Boolean of which the default value is set to FALSE, select TRUE in case you wish to retrieve the unique identifiers of documents outside the date range specified but linked to the “fact”. So let’s, for instance, query for some specific type of parliamentary work conducted in 2021. Here, we opt to retrieve data about parliamentary initiatives (fact=\u0026#34;parliamentary_initiatives\u0026#34;) discussed in the plenary (plen_comm=\u0026#34;plen\u0026#34;) sessions (date_range_from=\u0026#34;2021-01-01\u0026#34;and date_range_to=\u0026#34;2021-12-31\u0026#34;). We also specify that we are interested in the type=\u0026#34;details\u0026#34; as this will deliver us a data frame containing the essentials about each parliamentary initiative.\npi_work \u0026lt;- get_work(date_range_from=\u0026#34;2021-01-01\u0026#34; , date_range_to=\u0026#34;2021-12-31\u0026#34; , fact=\u0026#34;parliamentary_initiatives\u0026#34; , type=\u0026#34;details\u0026#34; , plen_comm=\u0026#34;plen\u0026#34;) pi_work %\u0026gt;% tibble() %\u0026gt;% head(10) %\u0026gt;% View Now we can inspect the data a bit more. Something you can check, for example, is which topics are covered in the parliamentary initiatives at that time. We use some dplyr code, in this case count() to quickly count the unique values in the column result_thema_1.\npi_work %\u0026gt;% count(result_thema_1, sort = T) -\u0026gt; work_topics work_topics Example 2 - Retrieving documents related to parliamentary work Here, we opt to retrieve data about written questions (fact=\u0026#34;written questions\u0026#34;) issued in March 2022 (date_range_from=\u0026#34;2022-03-01\u0026#34;and date_range_to=\u0026#34;2022-03-31\u0026#34;). Importantly, we specify that we are interested in type=\u0026#34;document\u0026#34; as this will deliver us a data frame containing the documents related to each written question in the selection.\nwq_work_doc \u0026lt;- get_work(date_range_from=\u0026#34;2022-03-01\u0026#34; , date_range_to=\u0026#34;2022-03-31\u0026#34; , fact=\u0026#34;written_questions\u0026#34; , type=\u0026#34;document\u0026#34;) wq_work_doc %\u0026gt;% tibble::tibble() %\u0026gt;% head(10) %\u0026gt;% View This call delivers you a data frame with (at least) the following columns:\nid_fact: unique identifier linking to the specific parliamentary activity the document is associated with (in this example, the written question) text: each row in this column contains the text contained in the document The data frame can be manipulated further to make it ready for text analysis. First, matching the data frame with the details of its associated written questions is possible via id_fact.\nwq_work \u0026lt;- get_work(date_range_from=\u0026#34;2022-03-01\u0026#34; , date_range_to=\u0026#34;2022-03-31\u0026#34; , fact=\u0026#34;written_questions\u0026#34; , type=\u0026#34;details\u0026#34;) wq_docs_details \u0026lt;- left_join(wq_work, wq_work_doc, by=c(\u0026#34;id_fact\u0026#34;)) Another element here is that we can search these documents for specific key words occurring in one of them. For this, we use the search_terms() function with the following arguments:\ntext_field: fill in the column name of the text field in c(“XXX”), multiple columns can be specified at once as c(“XXX”, “XXX”, …) search_terms: fill in the term(s) you want the documents checked for Here, we opt to retrieve data about the PFOS/PFAS debate in Belgium (search_terms = c(\u0026#34;PFOS\u0026#34;, \u0026#34;PFAS\u0026#34;)). …","date":1664064000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664064000,"objectID":"1690c3157057eb4627a4b345b18c3b4a","permalink":"/post/2022_09_27_post/","publishdate":"2022-09-25T00:00:00Z","relpermalink":"/post/2022_09_27_post/","section":"post","summary":"MP's at work.","tags":null,"title":"flempar_parliamentary work","type":"post"},{"authors":["Evelien Willems and Frederik Heylen"],"categories":null,"content":"knitr::opts_chunk$set(echo = TRUE) In this post we delve into the get_mp() function and the parameters you can specify to query for more specific information. The get_mp() function has the following arguments:\nselection: options are “current”, “former” or “date” when selecting “date”, “date_at” should be added as “YYYY-MM-DD” fact: options are “bio”, “career”, “education”, “presences_commissions”, “presences_plenary”, “political_info”, and “raw” use_parallel: Boolean of which the default value is set to TRUE, select FALSE in case you do not have multiple workers to speed up the calls made To retrieve the demographics of the MPs currently in parliament (same as default), we specify the following: selection=\u0026#34;current\u0026#34; and fact=\u0026#34;bio\u0026#34;. Note that you can each time store the data frame in your R-environment by including the following \u0026lt;- name data frame. This has the benefit of storing the data in a table containing rows and columns that you can use for further data manipulation and analysis.\nmp_bio \u0026lt;- get_mp(selection=\u0026#34;current\u0026#34; , fact=\u0026#34;bio\u0026#34;) mp_bio The result of our query is a data frame with 124 observations, the exact number of MPs currently in office, and their demographics. You will see that the data frame is successfully stored under the tab ‘Environment’. This is how the data frame looks like:\nYou can, for instance, check the distribution of men and women in parliament. We make use of the pipe operator %\u0026gt;% (which lets you pass an interim result onto the next function) and the data manipulation options from the dplyr package. To count observations by group, we use group_by() and tally(). You can find more information on how to use dplyr here.\nmp_bio %\u0026gt;% group_by(geslacht) %\u0026gt;% tally() Example 2 - Extracting demographics at specific dates So let’s take this a step further and analyze whether the number of women in parliament has grown throughout the years. To do so, we will extract the demographics of MPs from past legislatures (from 1995 onwards). We make use of the get_legislatures() function to identify the starting dates of each legislature.\nget_legislatures() Next, we specify the exact date from which we wish to collect the MPs’ demographics. Here, we opt for 01/12 of the starting year of each legislature, to make sure all MPs are sworn in. Instead of selection=\u0026#34;current\u0026#34;, we now fill in selection=\u0026#34;date\u0026#34;and add the date_at=\u0026#34;YYYY-MM-DD\u0026#34; argument in the the get_mp() function.\nmp_bio_1995 \u0026lt;- get_mp(selection=\u0026#34;date\u0026#34;, fact=\u0026#34;bio\u0026#34;, date_at =\u0026#34;1995-12-01\u0026#34;) mp_bio_1999 \u0026lt;- get_mp(selection=\u0026#34;date\u0026#34;, fact=\u0026#34;bio\u0026#34;, date_at =\u0026#34;1999-12-01\u0026#34;) mp_bio_2004 \u0026lt;- get_mp(selection=\u0026#34;date\u0026#34;, fact=\u0026#34;bio\u0026#34;, date_at =\u0026#34;2004-12-01\u0026#34;) mp_bio_2009 \u0026lt;- get_mp(selection=\u0026#34;date\u0026#34;, fact=\u0026#34;bio\u0026#34;, date_at =\u0026#34;2009-12-01\u0026#34;) mp_bio_2014 \u0026lt;- get_mp(selection=\u0026#34;date\u0026#34;, fact=\u0026#34;bio\u0026#34;, date_at =\u0026#34;2014-12-01\u0026#34;) mp_bio_2019 \u0026lt;- get_mp(selection=\u0026#34;date\u0026#34;, fact=\u0026#34;bio\u0026#34;, date_at =\u0026#34;2019-12-01\u0026#34;) Now, we will select the relevant columns to answer our question and add a column for year. We again make use of the pipe operator (which lets you pass an interim result onto the next function) and the data manipulation options from the dplyr package (here: select() and add_column()).\nmp_bio_1995 %\u0026gt;% select(id_mp, geslacht) %\u0026gt;% add_column(year = 1995) -\u0026gt; mp_bio_1995 mp_bio_1999 %\u0026gt;% select(id_mp, geslacht) %\u0026gt;% add_column(year = 1999) -\u0026gt; mp_bio_1999 mp_bio_2004 %\u0026gt;% select(id_mp, geslacht) %\u0026gt;% add_column(year = 2004) -\u0026gt; mp_bio_2004 mp_bio_2009 %\u0026gt;% select(id_mp, geslacht) %\u0026gt;% add_column(year = 2009) -\u0026gt; mp_bio_2009 mp_bio_2014 %\u0026gt;% select(id_mp, geslacht) %\u0026gt;% add_column(year = 2014) -\u0026gt; mp_bio_2014 mp_bio_2019 %\u0026gt;% select(id_mp, geslacht) %\u0026gt;% add_column(year = 2019) -\u0026gt; mp_bio_2019 Finally, we combine these data frames into a single data frame, making use of rbind(). This function allows to join data frames vertically, in other words, the data frames get pasted below each other.\nmp_pastlegis \u0026lt;- rbind(mp_bio_1995, mp_bio_1999, mp_bio_2004, mp_bio_2009, mp_bio_2014, mp_bio_2019) mp_pastlegis This data frame then allows us to answer our research question. Has the number of women MPs grown throughout the years? We opt to plot the results in a histogram, making use of the ggplot package. A good place to start learning about ggplot is here.\nplot1 \u0026lt;- ggplot(mp_pastlegis, aes(x = year, fill= geslacht, colour = geslacht), bins = 12) + geom_histogram(binwidth=1.5, position = \u0026#34;dodge\u0026#34;) + labs(x=\u0026#34;Year\u0026#34;, y = \u0026#34;Count\u0026#34;) + scale_x_continuous(breaks = c(1995, 1999, 2004, 2009, 2014, 2019)) + theme_classic() plot1 Quick elaboration (advanced) Above, we present some very elaborate code, but with the advantage of simplicity to intuitively understand it. Here, we do it in a shorter, elegant, but more complex way.\nlibrary(lubridate) leg \u0026lt;- get_legislatures() %\u0026gt;% filter(start \u0026gt;= ymd_hms(\u0026#34;1995-06-12 22:00:00\u0026#34;)) list \u0026lt;- vector(mode=\u0026#34;list\u0026#34;, length=length(leg)) for(i in 1:nrow(leg)){ list[[i]]\u0026lt;- get_mp(selection=\u0026#34;date\u0026#34;, fact=\u0026#34;bio\u0026#34;, date_at = date(leg$start[[i]]) + months(6), use_parallel=TRUE) } mp_pastlegis_2 \u0026lt;- …","date":1663977600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663977600,"objectID":"bace76fdc25ea3334cdfaaa8de8dc4bc","permalink":"/post/2022_09_26_post/","publishdate":"2022-09-24T00:00:00Z","relpermalink":"/post/2022_09_26_post/","section":"post","summary":"Who are the MPs?","tags":null,"title":"flempar_members of parliament","type":"post"},{"authors":["Evelien Willems and Frederik Heylen"],"categories":null,"content":"knitr::opts_chunk$set(echo = TRUE) Introduction The Flemish Parliament makes its database available via web services: http://ws.vlpar.be/e/opendata/api. These data are open and free to use without restrictions. The flempar R-package is made for querying the web API. It parses the API responses and transforms JSON into a useful object (i.e. data frame) for the end-user.\nThis R-package is the result of a collaboration between Wouter Van Dooren, Evelien Willems, both from the Department of Political Science at the University of Antwerp, and Frederik Heylen, founder of Datamarinier.\nIn this series of blog posts, we are going to use the flempar package to collect and analyze:\nKey characteristics of Flemish members of parliament (MPs): get_mp() Parliamentary work, including speeches and documents: get_work() We guide you through several specific research questions for each of these two functions to demonstrate the package’s various applications and showcase the wealth of available data. After going through all blog posts, you will be able to work out how to extract other data suited to your particular research questions from the API of the Flemish Parliament. But first things first, let’s get started!\nGetting started You can install the flempar package from the GitHub account of the Political Science Department of the University of Antwerp, https://github.com/PolscienceAntwerp/flempar. Mac users will also need to install Xcode.\nrequire(devtools) install_github(\u0026#34;PolscienceAntwerp/flempar\u0026#34;) We then load the flempar package along with the tidyverse suite of R packages to manipulate the data and visualize some results. Additionally, we load in data.table, making working with data frames easier (more info here).\nlibrary(flempar) library(dplyr) library(tidyr) library(tibble) library(ggplot2) library(stringr) library(data.table) In case you don’t have these extra R-packages already installed. Run the following code first, then run the above chunk of code.\ninstall.packages(\u0026#34;dplyr\u0026#34;) install.packages(\u0026#34;tidyr\u0026#34;) install.packages(\u0026#34;tibble\u0026#34;) install.packages(\u0026#34;ggplot2\u0026#34;) install.packages(\u0026#34;data.table\u0026#34;) Now, let’s test whether the installation worked! You can try running the get_mp() function with its default options, specifying no parameters. This delivers you the demographics of the current MPs. At the moment of writing this blog post, this comprises all MPs seating in the 2019-2024 legislature.\nget_mp() When making calls, you get feedback about the number of calls that will be made. Depending on the number of calls, this might take a couple of seconds to several minutes. If the call succeeds, the exact time needed to do so gets displayed.\nIn this regard, the build-in use_parallel=TRUE argument is one of the main advantages of using our flempar package. This functionality ensures that instead of serial processing (i.e. one batch after the other), your computer is told to divide the work among its processing cores to execute the work in parallel (i.e. simultaneously); which significantly speeds up the data retrieving process. So, in almost all instances, you will want keep the default-setting use_parallel=TRUE, which makes it unnecessary to explicitely specificy this as a parameter in the function.\nExample of feedback:\n✔ Getting the data. ✔ Making 124 calls. ✔ Made 124 calls in 149.5 seconds. What you get is a simple overview of the data. This is how the output looks like:\n![](Markdown images/DefaultOutput_get_mp.png)\nSo on to the get_work()function. In contrast to the get_mp function, you always need to specify a date range using the following arguments:\ndate_range_from: the start date YYYY-MM-DD date_range_to: the end date YYYY-MM-DD As an enormous amount of data can be retrieved through the get_work() function, it is highly recommended to test your query on a limited date range before expanding the date range to comprise multiple months to years. As no other parameters are specified, you end up the default data, namely info about plenary debates.\nget_work(date_range_from=\u0026#34;2022-03-01\u0026#34; , date_range_to=\u0026#34;2022-03-15\u0026#34;) Again, you get some performance feedback about the calls being made and a first rough look at the output.\nThat’s it, you’ve now covered the basics of the flempar package!\n","date":1662508800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1662508800,"objectID":"2d182bea6ad48098284cf6bb6d8cd395","permalink":"/post/2022_09_07_post/","publishdate":"2022-09-07T00:00:00Z","relpermalink":"/post/2022_09_07_post/","section":"post","summary":"Flempar - your gateway to the Flemish parliament data","tags":null,"title":"Getting started with flempar","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"","tags":null,"title":"","type":"widget_page"}]